import numpy as np
import logging
import statsmodels.api as sm
from scipy.stats import poisson, nbinom
from statsmodels.distributions import zipoisson
from patsy import dmatrix
from .loop_calling_handler import GenericLoopCallHandler


class Loop_ZIP(GenericLoopCallHandler):
    """
    Modeling HiChIP data using GLM. This object fit to ZIP distribution. Check README.md for details.
    """

    def fit_model(
        self,
        exog_model_formula="C ~ np.log(D) + np.log(L)",
        exog_infl_formula="1",
        disp_glm_summary=False,
    ):
        logging.info("Fitting data to ZeroInflatedPoisson model")
        # only used for zero_inflated model
        # model inflation term as constant
        exog_infl = dmatrix(exog_infl_formula, self.loop_metric).view()

        # fit distri
        self.glm_res = sm.ZeroInflatedPoisson.from_formula(
            formula=exog_model_formula,
            data=self.loop_metric,
            exog_infl=exog_infl,
        ).fit_regularized(maxiter=500, disp=0)

        # predict
        (
            self.loop_metric["P"],
            self.loop_metric["P_Infl"],
            self.loop_metric["E"],
        ) = self._zipoisson_p_vals(
            self.glm_res,
            self.loop_metric.C.values - 1,
            dmatrix(exog_model_formula.split("~")[1], self.loop_metric).view(),
            exog_infl,
        )

        logging.info(f"AIC: {self.glm_res.aic}")
        if disp_glm_summary:
            print(self.glm_res.summary())

        self.interaction_statistics = self.loop_metric.loc[
            self.loop_metric.C != 0
        ].copy()

        super().calc_qval()

    def re_fit(
        self,
        exog_model_formula="C ~ np.log(D) + np.log(L)",
        exog_infl_formula="1",
        disp_glm_summary=False,
    ):
        confident_interaction_index = self.interaction_statistics.index[
            (
                self.interaction_statistics.P
                <= 1 / len(self.interaction_statistics)
            )
        ]
        old_expected = self.interaction_statistics.E.copy()
        # confident_interaction_index = self.interaction_statistics.index[
        #     self.interaction_statistics.Q <= 1e-3
        # ]
        filter_loop_metric = self.loop_metric.loc[
            ~self.loop_metric.index.isin(confident_interaction_index)
        ]
        logging.info(
            f"{len(confident_interaction_index)} high confident interactions were removed from fitting"
        )

        exog_infl = dmatrix(exog_infl_formula, filter_loop_metric).view()
        # fit distri
        self.glm_res_1 = sm.ZeroInflatedPoisson.from_formula(
            formula=exog_model_formula,
            data=filter_loop_metric,
            exog_infl=exog_infl,
        ).fit_regularized(maxiter=500, disp=0)
        # predict
        (
            self.loop_metric["P"],
            self.loop_metric["P_Infl1"],
            self.loop_metric["E"],
        ) = self._zipoisson_p_vals(
            self.glm_res_1,
            self.loop_metric.C.values - 1,
            dmatrix(exog_model_formula.split("~")[1], self.loop_metric).view(),
            dmatrix(exog_infl_formula, self.loop_metric).view(),
        )

        logging.info(f"AIC: {self.glm_res_1.aic}")
        if disp_glm_summary:
            print(self.glm_res_1.summary())

        self.loop_metric_for_refit = self.loop_metric.loc[
            self.loop_metric.index.isin(confident_interaction_index)
        ]
        self.interaction_statistics = self.loop_metric.loc[
            self.loop_metric.C != 0
        ].copy()
        # update for expected interactions
        eps = np.square(
            old_expected - self.interaction_statistics.E.values
        ).sum()
        super().calc_qval()

        return eps

    def _zipoisson_p_vals(self, model_res, counts, exog, exog_infl):
        model, params = model_res.model, model_res.params
        params_infl = params[: model.k_inflate]
        params_main = params[model.k_inflate :]

        # base on fitted model, predict sf
        if len(exog_infl.shape) < 2:
            w = np.atleast_2d(model.model_infl.predict(params_infl, exog_infl))[
                :, None
            ]
        else:
            w = model.model_infl.predict(params_infl, exog_infl)[:, None]

        w = np.clip(w, np.finfo(float).eps, 1 - np.finfo(float).eps).flatten()
        mu = model.model_main.predict(params_main, exog)[:, None].flatten()

        return zipoisson.sf(counts, mu, w), w, (1 - w) * mu

    def estimate_mean_var(
        self, loop_metric_, nbins, filter_confident_loops=False
    ):
        """
        Create L, D grid. For loops in each grid with similar L and D, assume they were generated by same distribution.
        """
        if filter_confident_loops:
            # adjust high confident loop count to background level
            loop_metric = super().estimate_mean_var(
                loop_metric_,
                nbins,
                compute_grid_stats=False,
                return_loop_metric=True,
            )
            cut = 1 / len(self.interaction_statistics)
            loop_metric.loc[loop_metric.P <= cut, "C"] = np.ceil(
                loop_metric.loc[loop_metric.P <= cut, "E"]
            )

            # loop_metric = loop_metric.groupby(["L_BID", "D_BID"]).filter(
            #     lambda df: sum(df.C != 0) > 0
            # )
            # loop_metric = loop_metric.groupby(
            #     ["L_BID", "D_BID"], as_index=False
            # ).apply(
            #     lambda df: pd.concat(
            #         [
            #             df[(df.C != 0) & (df.P > cut)],
            #             df[df.C == 0].sample(
            #                 frac=(sum(df.C != 0) - sum(df.P <= cut))
            #                 / sum(df.C != 0)
            #             ),
            #         ]
            #     )
            # )
            super().estimate_mean_var(
                loop_metric,
                nbins,
                compute_grid_stats=True,
                return_loop_metric=False,
            )

        else:
            super().estimate_mean_var(
                loop_metric_,
                nbins,
                compute_grid_stats=True,
                return_loop_metric=False,
            )


class Loop_NB(GenericLoopCallHandler):
    """
    Modeling HiChIP data using GLM. This object fit to NB distribution. Check README.md for details.
    """

    def fit_model(
        self,
        exog_model_formula="C ~ np.log(D) + np.log(L)",
        disp_glm_summary=False,
    ):
        logging.info("Fitting data to NegativeBinomial model")
        # fit distri
        self.glm_res = sm.NegativeBinomial.from_formula(
            formula=exog_model_formula,
            data=self.loop_metric,
        ).fit_regularized(maxiter=500, disp=0)

        # predict
        alpha = np.exp(self.glm_res.params[-1])
        nb_size = 1 / alpha
        self.loop_metric["E"] = self.glm_res.predict(self.loop_metric)
        self.loop_metric["Alpha"] = alpha
        self.loop_metric["P"] = nbinom.sf(
            self.loop_metric.C.values - 1,
            nb_size,
            nb_size / (nb_size + self.loop_metric.E.values),
        )

        logging.info(f"AIC: {self.glm_res.aic}")
        if disp_glm_summary:
            print(self.glm_res.summary())

        self.interaction_statistics = self.loop_metric.loc[
            self.loop_metric.C != 0
        ].copy()

        super().calc_qval()

    def re_fit(
        self,
        exog_model_formula="C ~ np.log(D) + np.log(L)",
        disp_glm_summary=False,
    ):
        confident_interaction_index = self.interaction_statistics.index[
            (
                self.interaction_statistics.P
                <= 1 / len(self.interaction_statistics)
            )
        ]
        old_expected = self.interaction_statistics.E.copy()
        # confident_interaction_index = self.interaction_statistics.index[
        #     self.interaction_statistics.Q <= 1e-3
        # ]
        filter_loop_metric = self.loop_metric.loc[
            ~self.loop_metric.index.isin(confident_interaction_index)
        ]
        logging.info(
            f"{len(confident_interaction_index)} high confident interactions were removed from fitting"
        )

        # fit distri
        self.glm_res_1 = sm.NegativeBinomial.from_formula(
            formula=exog_model_formula,
            data=filter_loop_metric,
        ).fit_regularized(maxiter=500, disp=0)

        # predict
        alpha = np.exp(self.glm_res_1.params[-1])
        nb_size = 1 / alpha
        self.loop_metric["E"] = self.glm_res_1.predict(self.loop_metric)
        self.loop_metric["Alpha1"] = alpha
        self.loop_metric["P"] = nbinom.sf(
            self.loop_metric.C.values - 1,
            nb_size,
            nb_size / (nb_size + self.loop_metric.E.values),
        )

        logging.info(f"AIC: {self.glm_res_1.aic}")
        if disp_glm_summary:
            print(self.glm_res_1.summary())

        self.loop_metric_for_refit = self.loop_metric.loc[
            self.loop_metric.index.isin(confident_interaction_index)
        ]
        self.interaction_statistics = self.loop_metric.loc[
            self.loop_metric.C != 0
        ].copy()
        # update for expected interactions
        eps = np.square(
            old_expected - self.interaction_statistics.E.values
        ).sum()
        super().calc_qval()

        return eps


class Loop_Poisson(GenericLoopCallHandler):
    """ """

    def fit_model(
        self,
        exog_model_formula="C ~ np.log(D) + np.log(L)",
        disp_glm_summary=True,
    ):
        logging.info("Fitting data to Poisson model")
        self.glm_res = sm.Poisson.from_formula(
            formula=exog_model_formula,
            data=self.loop_metric,
        ).fit_regularized(maxiter=500, disp=0)

        # predict
        self.loop_metric["E"] = self.glm_res.predict(self.loop_metric)
        self.loop_metric["P"] = poisson.sf(
            self.loop_metric.C.values - 1,
            self.loop_metric.E.values,
        )

        logging.info(f"AIC: {self.glm_res.aic}")
        if disp_glm_summary:
            print(self.glm_res.summary())

        self.interaction_statistics = self.loop_metric.loc[
            self.loop_metric.C != 0
        ].copy()

        super().calc_qval()

    def re_fit(
        self,
        exog_model_formula="C ~ np.log(D) + np.log(L)",
        disp_glm_summary=True,
    ):
        confident_interaction_index = self.interaction_statistics.index[
            (self.interaction_statistics.P <= 1 / len(self.loop_metric))
        ]
        old_expected = self.interaction_statistics.E.copy()
        filter_loop_metric = self.loop_metric.loc[
            ~self.loop_metric.index.isin(confident_interaction_index)
        ]
        logging.info(
            f"{len(confident_interaction_index)} high confident interactions were removed from fitting"
        )

        self.glm_res_1 = sm.Poisson.from_formula(
            formula=exog_model_formula,
            data=filter_loop_metric,
        ).fit_regularized(maxiter=500, disp=0)
        self.loop_metric["E"] = self.glm_res_1.predict(self.loop_metric)
        self.loop_metric["P"] = poisson.sf(
            self.loop_metric.C.values - 1, self.loop_metric.E.values
        )

        self.loop_metric_for_refit = self.loop_metric.loc[
            self.loop_metric.index.isin(confident_interaction_index)
        ]

        logging.info(f"AIC: {self.glm_res_1.aic}")
        if disp_glm_summary:
            print(self.glm_res_1.summary())

        self.interaction_statistics = self.loop_metric.loc[
            self.loop_metric.C != 0
        ].copy()

        eps = np.square(
            old_expected - self.interaction_statistics.E.values
        ).sum()

        super().calc_qval()

        return eps
